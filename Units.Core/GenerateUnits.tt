<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq"#>
<#@ output extension=".cs" #>
namespace Numbers {
    public interface IReal<T> where T: IReal<T> {
        <# foreach(var meth in SelfOps) { #>
             public <#= meth.RetType ?? "T" #> Op<#= meth.Name  #>(T op2);
        <#  } #>
    }
}
<#  foreach(var r in RealDefs) { #>
namespace Numbers.<#= r.WrapName #>s {
    using Numbers;
    using System;
    using Scalar = Numbers.<#= r.WrapName #>s.<#= r.WrapName #>;

    public readonly struct <#=  r.WrapName #> : IEquatable<<#=  r.WrapName #>>, IReal<<#= r.WrapName #>> {
        private readonly <#= r.ClrName #> _data;
        public <#=  r.WrapName #>(<#= r.ClrName #> data) {
            _data = data;
        }
        public <#=  r.WrapName #>(<#= r.WrapName #> data) {
            _data = data._data;
        }
        public static implicit operator <#=  r.WrapName #>(<#= r.ClrName #> raw) => new <#= r.WrapName #>(raw);
        public static explicit operator <#=  r.ClrName #>(<#= r.WrapName #> raw) => raw._data;
        <# foreach(var meth in SelfOps) { #>
            public <#= meth.RetType ?? r.WrapName #> Op<#= meth.Name  #>(<#= r.WrapName #> op2) {
                return _data <#=  meth.Symbol #> op2._data;
            }
            public static <#=  meth.RetType ?? r.WrapName #> operator <#=  meth.Symbol #>(<#= r.WrapName #> op1, <#= r.WrapName #> op2) {
                <#  if (meth.RetType != null) { #>
                return op1._data <#=  meth.Symbol #> op2._data;
                <#  } else { #>
                return new <#=  r.WrapName #>(op1._data <#=  meth.Symbol #> op2._data);
                <#  } #>
            }
        <#  } #>
        <#=  EdgeOps(Scalar) #>
        public override bool Equals(object obj) => obj is <#=  r.WrapName #> wn && Equals(wn);
        public bool Equals(<#=  r.WrapName #> other) => this._data == other._data;
        public override int GetHashCode() => _data.GetHashCode();
        public override string ToString() => _data.ToString();
    }
}
<#  } #>
<#  foreach(var real in RealDefs) { #>
namespace Units.<#= real.WrapName #> {
    using Numbers.<#= real.WrapName #>s;
    using System;
    using Scalar = Numbers.<#= real.WrapName #>s.<#= real.WrapName #>;

<#  foreach(var unit in Units.Where(i => i.Name != "Scalar")) { #>
<#  Console.WriteLine(unit); #>
    public readonly struct <#= unit.Name  #>: IEquatable<<#= unit.Name  #>> {
        public readonly Scalar RawValue;
        public <#=  unit.Name #>(Scalar value) {
            RawValue = value;
        }
        <# foreach(var meth in SelfOps.Where(i => i.Symbol != "*" && i.Symbol != "/")) { #>
            public static <#=  meth.RetType ?? unit.Name #> operator <#=  meth.Symbol #>(<#= unit.Name #> op1, <#= unit.Name #> op2) =>
                <#  if (meth.RetType == null) { #>
                new <#=  unit.Name #>(op1.RawValue.Op<#=  meth.Name #>(op2.RawValue));
                <#  } else { #>
                <#=  unit.Name #>(op1.RawValue.Op<#=  meth.Name #>(op2.RawValue));;
                <#  } #>
        <#  } #>
        <#=  EdgeOps(unit) #>

        public static explicit operator <#= unit.Name #>(<#= real.ClrName #> from) => new <#=  unit.Name #>(from);
        public static explicit operator <#= unit.Name #>(Scalar from) => new <#=  unit.Name #>(from);
        public static explicit operator Scalar(<#= unit.Name #> from) => from.RawValue;
        public static explicit operator <#= real.ClrName #>(<#= unit.Name #> from) => (<#= real.ClrName #>)from.RawValue;
        public override bool Equals(object obj) => obj is <#= unit.Name  #> ut && this.Equals(ut);
        public bool Equals(<#= unit.Name #> other) => true; //return other != null && this == other;
        public override int GetHashCode() => RawValue.GetHashCode();
    }
<#  } #>
}
<#  } #>